from rest_framework.decorators import api_view, parser_classes
from rest_framework.parsers import JSONParser, MultiPartParser, FormParser
from rest_framework.response import Response
from utils.logging_utils import get_logger
from intel_core.serializers import DocumentSerializer
from intel_core.services import DocumentService
from prompts.models import Prompt
from prompts.utils.token_helpers import count_tokens
from prompts.utils.diagnostics import update_prompt_diagnostics
from assistants.models import Assistant
from mcp_core.models import Tag
import json

logger = get_logger("django")
@api_view(["POST"])
@parser_classes([MultiPartParser, FormParser, JSONParser])
def unified_ingestion_view(request):
    """
    Accepts YouTube URLs, web URLs, or PDF uploads and ingests them into the system.
    """
    logger.info("ðŸ”¥ /intel/ingest triggered with body: %s", request.data)
    source_type = request.data.get("source_type")  # "youtube", "pdf", or "url"
    logger.info("ðŸ§­ Source Type Received: %s", source_type)

    if source_type == "youtube":
        logger.info("ðŸŽ¥ Routing to ingest_videos()")

    project_name = request.data.get("project_name", "General")
    session_id = request.data.get("session_id")
    user_provided_title = request.data.get("title")
    assistant_id = request.data.get("assistant_id")
    if not assistant_id:
        return Response({"error": "assistant_id required"}, status=400)
    project_id = request.data.get("project_id")
    reflect_after = str(request.data.get("reflect_after", "false")).lower() in [
        "1",
        "true",
        "yes",
    ]
    create_prompt = (
        str(request.data.get("create_prompt", "false")).lower() in ["1", "true", "yes"]
    )
    set_as_system = (
        str(request.data.get("set_as_system_prompt", "false")).lower()
        in ["1", "true", "yes"]
    )

    urls = request.data.get("urls")
    if isinstance(urls, str):
        urls = [urls]

    tag_names = request.data.get("tags", [])
    if isinstance(tag_names, str):
        try:
            tag_names = json.loads(tag_names)
        except Exception:
            tag_names = [t.strip() for t in tag_names.split(",") if t.strip()]

    uploaded_files = request.FILES.getlist("files")

    try:
        docs = DocumentService.ingest(
            source_type=source_type,
            urls=urls,
            files=uploaded_files,
            title=user_provided_title,
            project_name=project_name,
            session_id=session_id,
            assistant_id=assistant_id,
            project_id=project_id,
            tags=tag_names,
        )

        assistant = (
            Assistant.objects.filter(id=assistant_id).first()
            or Assistant.objects.filter(slug=assistant_id).first()
        )

        if create_prompt and docs:
            for doc in docs:
                topic = doc.metadata.get("topic") or project_name
                prompt_text = (
                    f"You are an AI assistant specialized in helping with: {topic}.\n"
                    f'You have reviewed the following source: "{doc.title}".\n'
                    "Use context from the memory linked to this document to assist users in completing related tasks, planning agents, or explaining related topics. Do not guess. If a topic is missing from memory, ask the user to upload more guidance."
                )
                prompt = Prompt.objects.create(
                    title=f"Autogenerated from {doc.title}"[:255],
                    type="system",
                    content=prompt_text,
                    source=f"document:{doc.id}",
                    tone="neutral",
                    assistant=assistant,
                    source_document=doc,
                    complexity=round(
                        doc.chunks.filter(anchor__isnull=False).count()
                        / max(doc.chunks.count(), 1),
                        2,
                    ),
                    token_count=count_tokens(prompt_text),
                )
                for name in ["autogen", "source:doc"]:
                    tag_obj, _ = Tag.objects.get_or_create(name=name)
                    prompt.tags.add(tag_obj)
                if assistant:
                    tag_obj, _ = Tag.objects.get_or_create(
                        name=f"linked_to:{assistant.slug}"
                    )
                    prompt.tags.add(tag_obj)
                update_prompt_diagnostics(prompt)

                if set_as_system and assistant:
                    assistant.system_prompt = prompt
                    update_fields = ["system_prompt"]
                    if not assistant.tone:
                        assistant.tone = "neutral"
                        update_fields.append("tone")
                    if not assistant.specialty:
                        assistant.specialty = topic
                        update_fields.append("specialty")
                    if not assistant.personality and doc.summary:
                        assistant.personality = doc.summary[:300]
                        update_fields.append("personality")
                    assistant.save(update_fields=update_fields)

        if reflect_after and docs and assistant:
            from assistants.utils.assistant_reflection_engine import (
                AssistantReflectionEngine,
            )
            engine = AssistantReflectionEngine(assistant)
            for doc in docs:
                try:
                    engine.reflect_on_document(doc)
                except Exception:
                    pass

        serialized = [DocumentSerializer(doc).data for doc in docs]
        response = {"documents": serialized}
        if create_prompt and docs:
            response["prompts"] = [str(p.id) for p in Prompt.objects.filter(source_document__in=docs, assistant=assistant)]
        if source_type == "url":
            response["message"] = f"Loaded {len(serialized)} URL document(s)."
        return Response(response)

    except Exception as e:
        return Response({"error": str(e)}, status=500)
